import { NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';

// Types for detection data
interface Detection {
  type: 'Feature';
  geometry: {
    type: 'Point';
    coordinates: [number, number];
  };
  properties: {
    probability: number;
    lat: number;
    lon: number;
    detected_at?: string;
    region?: string;
    area_ha?: number;
    is_licensed?: boolean;
  };
}

interface DetectionGeoJSON {
  type: 'FeatureCollection';
  features: Detection[];
  metadata?: {
    generated_at: string;
    model_version: string;
    regions: string[];
    total_detections: number;
  };
}

// Cache for performance
let cachedData: DetectionGeoJSON | null = null;
let cacheTime: number = 0;
const CACHE_TTL = 60 * 1000; // 1 minute cache

/**
 * GET /api/detections
 * 
 * Query Parameters:
 * - region: Filter by region name (e.g., "ghana_tarkwa", "ghana_obuasi")
 * - min_confidence: Minimum probability threshold (0-1)
 * - licensed: Filter by license status ("true", "false", "all")
 * - limit: Maximum number of results
 * - format: "geojson" (default) or "summary"
 */
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const region = searchParams.get('region');
    const minConfidence = parseFloat(searchParams.get('min_confidence') || '0');
    const licensed = searchParams.get('licensed');
    const limit = parseInt(searchParams.get('limit') || '0');
    const format = searchParams.get('format') || 'geojson';

    // Load detection data (with caching)
    const data = await loadDetectionData();

    // Apply filters
    let features = data.features;

    if (region) {
      features = features.filter(f => 
        f.properties.region?.toLowerCase().includes(region.toLowerCase())
      );
    }

    if (minConfidence > 0) {
      features = features.filter(f => f.properties.probability >= minConfidence);
    }

    if (licensed === 'true') {
      features = features.filter(f => f.properties.is_licensed === true);
    } else if (licensed === 'false') {
      features = features.filter(f => f.properties.is_licensed === false);
    }

    // Sort by probability (highest first)
    features = features.sort((a, b) => b.properties.probability - a.properties.probability);

    // Apply limit
    if (limit > 0) {
      features = features.slice(0, limit);
    }

    // Return format
    if (format === 'summary') {
      return NextResponse.json({
        total: features.length,
        high_confidence: features.filter(f => f.properties.probability >= 0.9).length,
        medium_confidence: features.filter(f => f.properties.probability >= 0.7 && f.properties.probability < 0.9).length,
        low_confidence: features.filter(f => f.properties.probability >= 0.5 && f.properties.probability < 0.7).length,
        by_region: groupByRegion(features),
        last_updated: data.metadata?.generated_at,
        model_version: data.metadata?.model_version,
      });
    }

    return NextResponse.json({
      type: 'FeatureCollection',
      features,
      metadata: {
        ...data.metadata,
        filtered_count: features.length,
        total_count: data.features.length,
      }
    });

  } catch (error) {
    console.error('Error loading detections:', error);
    return NextResponse.json(
      { error: 'Failed to load detection data', message: (error as Error).message },
      { status: 500 }
    );
  }
}

async function loadDetectionData(): Promise<DetectionGeoJSON> {
  // Check cache
  if (cachedData && Date.now() - cacheTime < CACHE_TTL) {
    return cachedData;
  }

  // Try to load from data directory first (production)
  const dataDir = path.join(process.cwd(), 'public', 'data');
  const publicDir = path.join(process.cwd(), 'public');

  // Priority order for loading detection data
  const possiblePaths = [
    path.join(dataDir, 'latest_detections.geojson'),        // Auto-generated by CI/CD
    path.join(dataDir, 'ghana_mining_detections.geojson'),  // Regional aggregate
    path.join(publicDir, 'ghana_tarkwa_mining_wgs84.geojson'), // Legacy static file
  ];

  for (const filePath of possiblePaths) {
    try {
      const fileContents = await fs.readFile(filePath, 'utf-8');
      const data = JSON.parse(fileContents) as DetectionGeoJSON;
      
      // Add metadata if missing
      if (!data.metadata) {
        const stats = await fs.stat(filePath);
        data.metadata = {
          generated_at: stats.mtime.toISOString(),
          model_version: 'unknown',
          regions: extractRegions(data.features),
          total_detections: data.features.length,
        };
      }

      // Enrich features with region if missing
      data.features = data.features.map(f => ({
        ...f,
        properties: {
          ...f.properties,
          region: f.properties.region || inferRegion(f.geometry.coordinates),
        }
      }));

      cachedData = data;
      cacheTime = Date.now();
      return data;
    } catch {
      continue; // Try next path
    }
  }

  throw new Error('No detection data found. Run detection pipeline first.');
}

function groupByRegion(features: Detection[]): Record<string, number> {
  return features.reduce((acc, f) => {
    const region = f.properties.region || 'unknown';
    acc[region] = (acc[region] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
}

function extractRegions(features: Detection[]): string[] {
  const regions = new Set(features.map(f => f.properties.region).filter(Boolean));
  return Array.from(regions) as string[];
}

function inferRegion(coords: [number, number]): string {
  // Ghana mining regions bounding boxes
  const regions = [
    { name: 'ghana_tarkwa', bbox: [-2.1, 5.1, -1.8, 5.5] },
    { name: 'ghana_obuasi', bbox: [-1.8, 6.1, -1.5, 6.4] },
    { name: 'ghana_bibiani', bbox: [-2.4, 6.3, -2.1, 6.6] },
    { name: 'ghana_konongo', bbox: [-1.3, 6.5, -1.0, 6.8] },
    { name: 'ghana_dunkwa', bbox: [-1.9, 5.9, -1.6, 6.2] },
  ];

  for (const region of regions) {
    const [minLon, minLat, maxLon, maxLat] = region.bbox;
    if (coords[0] >= minLon && coords[0] <= maxLon && 
        coords[1] >= minLat && coords[1] <= maxLat) {
      return region.name;
    }
  }
  return 'ghana_other';
}
